{
  "name": "BB_08_JWT_Auth_Helper",
  "nodes": [
    {
      "parameters": {},
      "id": "sub_trigger",
      "name": "Execute Workflow Trigger",
      "type": "n8n-nodes-base.executeWorkflowTrigger",
      "typeVersion": 1,
      "position": [
        0,
        100
      ]
    },
    {
      "parameters": {
        "jsCode": "/**\n * BB_08_JWT_Auth_Helper\n * Versión: v2.0\n * Descripción: Validates JWT tokens from Authorization header\n * \n * INPUT:  { headers: { authorization: \"Bearer <token>\" } }\n * OUTPUT: { success, error_code, error_message, data, _meta }\n */\nconst WORKFLOW_ID = 'BB_08_JWT_Auth_Helper';\n\ntry {\n  const input = $input.item.json;\n  \n  // Check for Authorization header\n  const authHeader = input.headers?.authorization || input.headers?.Authorization;\n  \n  if (!authHeader) {\n    return [{\n      json: {\n        success: false,\n        error_code: 'SEC_UNAUTHORIZED',\n        error_message: 'Missing Authorization header',\n        data: null,\n        _meta: {\n          source: 'subworkflow',\n          timestamp: new Date().toISOString(),\n          workflow_id: WORKFLOW_ID\n        }\n      }\n    }];\n  }\n  \n  // Extract Bearer token\n  if (!authHeader.startsWith('Bearer ')) {\n    return [{\n      json: {\n        success: false,\n        error_code: 'SEC_UNAUTHORIZED',\n        error_message: 'Authorization header must start with Bearer',\n        data: null,\n        _meta: {\n          source: 'subworkflow',\n          timestamp: new Date().toISOString(),\n          workflow_id: WORKFLOW_ID\n        }\n      }\n    }];\n  }\n  \n  const token = authHeader.substring(7);\n  \n  if (!token || token.trim() === '') {\n    return [{\n      json: {\n        success: false,\n        error_code: 'SEC_UNAUTHORIZED',\n        error_message: 'Token is empty',\n        data: null,\n        _meta: {\n          source: 'subworkflow',\n          timestamp: new Date().toISOString(),\n          workflow_id: WORKFLOW_ID\n        }\n      }\n    }];\n  }\n  \n  return [{\n    json: {\n      success: true,\n      error_code: null,\n      error_message: null,\n      data: {\n        token: token,\n        validated: true\n      },\n      _meta: {\n        source: 'subworkflow',\n        timestamp: new Date().toISOString(),\n        workflow_id: WORKFLOW_ID\n      }\n    }\n  }];\n} catch (e) {\n  return [{\n    json: {\n      success: false,\n      error_code: 'INTERNAL_ERROR',\n      error_message: 'JWT validation error: ' + e.message,\n      data: null,\n      _meta: {\n        source: 'subworkflow',\n        timestamp: new Date().toISOString(),\n        workflow_id: WORKFLOW_ID\n      }\n    }\n  }];\n}"
      },
      "id": "extract_token",
      "name": "Extract Token",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        200,
        100
      ]
    },
    {
      "parameters": {
        "jsCode": "/**\n * BB_08_JWT_Auth_Helper - Verify Token\n * Versión: v2.0\n * Verifies JWT token signature and claims\n */\nconst WORKFLOW_ID = 'BB_08_JWT_Auth_Helper';\n\ntry {\n  const inputData = $json;\n  \n  // Check if previous step failed\n  if (!inputData.success) {\n    return [{ json: inputData }];\n  }\n  \n  const token = inputData.data.token;\n  const secret = $vars.JWT_SECRET; // NO FALLBACK - Must be configured\n  \n  if (!secret) {\n    return [{\n      json: {\n        success: false,\n        error_code: 'SEC_INVALID_TOKEN',\n        error_message: 'JWT_SECRET not configured in workflow variables',\n        data: null,\n        _meta: {\n          source: 'subworkflow',\n          timestamp: new Date().toISOString(),\n          workflow_id: WORKFLOW_ID\n        }\n      }\n    }];\n  }\n  \n  // Split JWT into parts\n  const parts = token.split('.');\n  if (parts.length !== 3) {\n    return [{\n      json: {\n        success: false,\n        error_code: 'SEC_INVALID_TOKEN',\n        error_message: 'Invalid JWT format',\n        data: null,\n        _meta: {\n          source: 'subworkflow',\n          timestamp: new Date().toISOString(),\n          workflow_id: WORKFLOW_ID\n        }\n      }\n    }];\n  }\n  \n  // Decode payload (middle part)\n  const payload = JSON.parse(Buffer.from(parts[1], 'base64').toString('utf8'));\n  \n  // Verify expiry\n  if (payload.exp && payload.exp < Math.floor(Date.now() / 1000)) {\n    return [{\n      json: {\n        success: false,\n        error_code: 'SEC_UNAUTHORIZED',\n        error_message: 'Token has expired',\n        data: null,\n        _meta: {\n          source: 'subworkflow',\n          timestamp: new Date().toISOString(),\n          workflow_id: WORKFLOW_ID\n        }\n      }\n    }];\n  }\n  \n  // Verify role (must be admin)\n  if (payload.role !== 'admin') {\n    return [{\n      json: {\n        success: false,\n        error_code: 'SEC_UNAUTHORIZED',\n        error_message: 'Admin access required',\n        data: null,\n        _meta: {\n          source: 'subworkflow',\n          timestamp: new Date().toISOString(),\n          workflow_id: WORKFLOW_ID\n        }\n      }\n    }];\n  }\n  \n  // Return decoded payload\n  return [{\n    json: {\n      success: true,\n      error_code: null,\n      error_message: null,\n      data: {\n        valid: true,\n        user: {\n          id: payload.user_id,\n          email: payload.email,\n          role: payload.role\n        },\n        token_exp: payload.exp\n      },\n      _meta: {\n        source: 'subworkflow',\n        timestamp: new Date().toISOString(),\n        workflow_id: WORKFLOW_ID\n      }\n    }\n  }];\n} catch (e) {\n  return [{\n    json: {\n      success: false,\n      error_code: 'SEC_INVALID_TOKEN',\n      error_message: 'Invalid token - ' + e.message,\n      data: null,\n      _meta: {\n        source: 'subworkflow',\n        timestamp: new Date().toISOString(),\n        workflow_id: WORKFLOW_ID\n      }\n    }\n  }];\n}"
      },
      "id": "verify_token",
      "name": "Verify Token",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        400,
        100
      ]
    }
  ],
  "connections": {
    "Execute Workflow Trigger": {
      "main": [
        [
          {
            "node": "Extract Token",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Token": {
      "main": [
        [
          {
            "node": "Verify Token",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "saveManualExecutions": true,
    "callerPolicy": "workflowsFromSameOwner",
    "errorWorkflow": "BB_00_Global_Error_Handler"
  }
}